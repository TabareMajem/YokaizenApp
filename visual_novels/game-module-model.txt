import 'package:flutter/material.dart';
import 'package:uuid/uuid.dart';

enum GameType {
  taskDash,    // Procrastination management
  stressEscape, // Relaxation and mindfulness
  confidenceQuest, // Self-esteem building
}

enum GameElementType {
  platform,
  obstacle,
  collectible,
  powerUp,
  checkpoint,
  background,
  trigger,
}

class GameModule {
  final String id;
  final String title;
  final String description;
  final GameType gameType;
  final String difficulty;
  final int estimatedDuration; // in seconds
  final String targetSkill;
  final String backgroundImage;
  final PhysicsConfig physics;
  final List<GameElement> gameElements;
  final PlayerCharacter character;
  final List<GameObstacle> obstacles;
  final List<GameReward> rewards;
  final List<Stat> stats;
  
  GameModule({
    required this.id,
    required this.title,
    required this.description,
    required this.gameType,
    required this.difficulty,
    required this.estimatedDuration,
    required this.targetSkill,
    required this.backgroundImage,
    required this.physics,
    required this.gameElements,
    required this.character,
    required this.obstacles,
    required this.rewards,
    required this.stats,
  });
  
  // Create a new game module with default values
  factory GameModule.createDefault(GameType type) {
    const uuid = Uuid();
    
    // Set default title based on game type
    String title;
    String description;
    String backgroundImage;
    
    switch (type) {
      case GameType.taskDash:
        title = 'Task Dash';
        description = 'Navigate through distractions to collect task tokens';
        backgroundImage = 'office_space.png';
        break;
      case GameType.stressEscape:
        title = 'Stress Escape';
        description = 'Find your way through a relaxation maze';
        backgroundImage = 'forest_path.png';
        break;
      case GameType.confidenceQuest:
        title = 'Confidence Quest';
        description = 'Build confidence through challenges and affirmations';
        backgroundImage = 'mountain_climb.png';
        break;
    }
    
    return GameModule(
      id: uuid.v4(),
      title: title,
      description: description,
      gameType: type,
      difficulty: 'medium',
      estimatedDuration: 60, // 60 seconds default
      targetSkill: _getDefaultSkill(type),
      backgroundImage: backgroundImage,
      physics: PhysicsConfig(
        gravity: 9.8,
        bounce: 0.2,
        speed: 5.0,
      ),
      gameElements: [],
      character: PlayerCharacter(
        id: uuid.v4(),
        name: 'Player',
        spriteImage: 'default_character.png',
        movementType: MovementType.run,
        jumpHeight: 5.0,
        speed: 5.0,
        abilities: [],
      ),
      obstacles: _getDefaultObstacles(type),
      rewards: _getDefaultRewards(type),
      stats: _getDefaultStats(type),
    );
  }
  
  // Copy with method for immutability
  GameModule copyWith({
    String? id,
    String? title,
    String? description,
    GameType? gameType,
    String? difficulty,
    int? estimatedDuration,
    String? targetSkill,
    String? backgroundImage,
    PhysicsConfig? physics,
    List<GameElement>? gameElements,
    PlayerCharacter? character,
    List<GameObstacle>? obstacles,
    List<GameReward>? rewards,
    List<Stat>? stats,
  }) {
    return GameModule(
      id: id ?? this.id,
      title: title ?? this.title,
      description: description ?? this.description,
      gameType: gameType ?? this.gameType,
      difficulty: difficulty ?? this.difficulty,
      estimatedDuration: estimatedDuration ?? this.estimatedDuration,
      targetSkill: targetSkill ?? this.targetSkill,
      backgroundImage: backgroundImage ?? this.backgroundImage,
      physics: physics ?? this.physics,
      gameElements: gameElements ?? this.gameElements,
      character: character ?? this.character,
      obstacles: obstacles ?? this.obstacles,
      rewards: rewards ?? this.rewards,
      stats: stats ?? this.stats,
    );
  }
  
  // Convert to JSON for storage and API
  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'title': title,
      'description': description,
      'gameType': gameType.toString().split('.').last,
      'difficulty': difficulty,
      'estimatedDuration': estimatedDuration,
      'targetSkill': targetSkill,
      'backgroundImage': backgroundImage,
      'physics': physics.toJson(),
      'gameElements': gameElements.map((e) => e.toJson()).toList(),
      'character': character.toJson(),
      'obstacles': obstacles.map((o) => o.toJson()).toList(),
      'rewards': rewards.map((r) => r.toJson()).toList(),
      'stats': stats.map((s) => s.toJson()).toList(),
    };
  }
  
  // Create from JSON
  factory GameModule.fromJson(Map<String, dynamic> json) {
    return GameModule(
      id: json['id'],
      title: json['title'],
      description: json['description'],
      gameType: GameType.values.firstWhere(
        (e) => e.toString().split('.').last == json['gameType'],
        orElse: () => GameType.taskDash,
      ),
      difficulty: json['difficulty'],
      estimatedDuration: json['estimatedDuration'],
      targetSkill: json['targetSkill'],
      backgroundImage: json['backgroundImage'],
      physics: PhysicsConfig.fromJson(json['physics']),
      gameElements: (json['gameElements'] as List)
          .map((e) => GameElement.fromJson(e))
          .toList(),
      character: PlayerCharacter.fromJson(json['character']),
      obstacles: (json['obstacles'] as List)
          .map((o) => GameObstacle.fromJson(o))
          .toList(),
      rewards: (json['rewards'] as List)
          .map((r) => GameReward.fromJson(r))
          .toList(),
      stats: (json['stats'] as List)
          .map((s) => Stat.fromJson(s))
          .toList(),
    );
  }
  
  // Generate Flame game configuration
  Map<String, dynamic> toFlameConfig() {
    // Convert the game module to a format that can be used by the Flame engine
    return {
      'id': id,
      'title': title,
      'gameType': gameType.toString().split('.').last,
      'backgroundImage': backgroundImage,
      'physics': {
        'gravity': physics.gravity,
        'bounce': physics.bounce,
        'speed': physics.speed,
      },
      'character': {
        'sprite': character.spriteImage,
        'movementType': character.movementType.toString().split('.').last,
        'jumpHeight': character.jumpHeight,
        'speed': character.speed,
        'abilities': character.abilities,
      },
      'elements': gameElements.map((element) => {
        'id': element.id,
        'type': element.type.toString().split('.').last,
        'x': element.position.dx,
        'y': element.position.dy,
        'width': element.size.width,
        'height': element.size.height,
        'properties': element.properties,
      }).toList(),
      'obstacles': obstacles.map((obstacle) => {
        'id': obstacle.id,
        'type': obstacle.type,
        'sprite': obstacle.sprite,
        'movementPattern': obstacle.movementPattern.toString().split('.').last,
        'speed': obstacle.speed,
        'damage': obstacle.damage,
        'spawnRate': obstacle.spawnRate,
        'properties': obstacle.properties,
      }).toList(),
      'rewards': rewards.map((reward) => {
        'id': reward.id,
        'type': reward.type,
        'sprite': reward.sprite,
        'value': reward.value,
        'effect': reward.effect,
        'duration': reward.duration,
        'properties': reward.properties,
      }).toList(),
      'stats': stats.map((stat) => {
        'id': stat.id,
        'name': stat.name,
        'icon': stat.icon,
        'initialValue': stat.initialValue,
        'maxValue': stat.maxValue,
      }).toList(),
    };
  }
  
  // Helper methods for default game configurations
  static String _getDefaultSkill(GameType type) {
    switch (type) {
      case GameType.taskDash:
        return 'focus';
      case GameType.stressEscape:
        return 'relaxation';
      case GameType.confidenceQuest:
        return 'confidence';
    }
  }
  
  static List<GameObstacle> _getDefaultObstacles(GameType type) {
    const uuid = Uuid();
    
    switch (type) {
      case GameType.taskDash:
        return [
          GameObstacle(
            id: uuid.v4(),
            type: 'social_media',
            sprite: 'social_media_icon.png',
            movementPattern: MovementPattern.linear,
            speed: 3.0,
            damage: 10,
            spawnRate: 2.0,
            properties: {'distraction_level': 8},
          ),
          GameObstacle(
            id: uuid.v4(),
            type: 'tv',
            sprite: 'tv_icon.png',
            movementPattern: MovementPattern.zigzag,
            speed: 2.0,
            damage: 15,
            spawnRate: 5.0,
            properties: {'distraction_level': 9},
          ),
        ];
      
      case GameType.stressEscape:
        return [
          GameObstacle(
            id: uuid.v4(),
            type: 'stress_cloud',
            sprite: 'stress_cloud.png',
            movementPattern: MovementPattern.follow,
            speed: 1.5,
            damage: 5,
            spawnRate: 3.0,
            properties: {'stress_level': 7},
          ),
          GameObstacle(
            id: uuid.v4(),
            type: 'deadline',
            sprite: 'deadline_clock.png',
            movementPattern: MovementPattern.circular,
            speed: 2.5,
            damage: 12,
            spawnRate: 7.0,
            properties: {'stress_level': 9},
          ),
        ];
      
      case GameType.confidenceQuest:
        return [
          GameObstacle(
            id: uuid.v4(),
            type: 'doubt_ghost',
            sprite: 'doubt_ghost.png',
            movementPattern: MovementPattern.follow,
            speed: 2.0,
            damage: 8,
            spawnRate: 4.0,
            properties: {'confidence_drain': 5},
          ),
          GameObstacle(
            id: uuid.v4(),
            type: 'criticism',
            sprite: 'criticism_bubble.png',
            movementPattern: MovementPattern.bounce,
            speed: 3.0,
            damage: 10,
            spawnRate: 6.0,
            properties: {'confidence_drain': 7},
          ),
        ];
    }
  }
  
  static List<GameReward> _getDefaultRewards(GameType type) {
    const uuid = Uuid();
    
    switch (type) {
      case GameType.taskDash:
        return [
          GameReward(
            id: uuid.v4(),
            type: 'task_token',
            sprite: 'task_token.png',
            value: 10,
            effect: 'progress_boost',
            duration: 0,
            properties: {'completion_points': 1},
          ),
          GameReward(
            id: uuid.v4(),
            type: 'focus_potion',
            sprite: 'focus_potion.png',
            value: 25,
            effect: 'slow_time',
            duration: 5,
            properties: {'distraction_immunity': true},
          ),
        ];
      
      case GameType.stressEscape:
        return [
          GameReward(
            id: uuid.v4(),
            type: 'calm_crystal',
            sprite: 'calm_crystal.png',
            value: 15,
            effect: 'stress_reduction',
            duration: 0,
            properties: {'relaxation_points': 1},
          ),
          GameReward(
            id: uuid.v4(),
            type: 'meditation_orb',
            sprite: 'meditation_orb.png',
            value: 30,
            effect: 'barrier',
            duration: 8,
            properties: {'stress_immunity': true},
          ),
        ];
      
      case GameType.confidenceQuest:
        return [
          GameReward(
            id: uuid.v4(),
            type: 'affirmation',
            sprite: 'affirmation_scroll.png',
            value: 20,
            effect: 'confidence_boost',
            duration: 0,
            properties: {'esteem_points': 1},
          ),
          GameReward(
            id: uuid.v4(),
            type: 'courage_trophy',
            sprite: 'courage_trophy.png',
            value: 35,
            effect: 'invincibility',
            duration: 6,
            properties: {'doubt_immunity': true},
          ),
        ];
    }
  }
  
  static List<Stat> _getDefaultStats(GameType type) {
    switch (type) {
      case GameType.taskDash:
        return [
          Stat(id: 'focus', name: 'Focus', icon: 'target', initialValue: 50, maxValue: 100),
          Stat(id: 'productivity', name: 'Productivity', icon: 'trending_up', initialValue: 0, maxValue: 100),
          Stat(id: 'discipline', name: 'Discipline', icon: 'fitness_center', initialValue: 30, maxValue: 100),
        ];
      
      case GameType.stressEscape:
        return [
          Stat(id: 'calmness', name: 'Calmness', icon: 'spa', initialValue: 40, maxValue: 100),
          Stat(id: 'mindfulness', name: 'Mindfulness', icon: 'self_improvement', initialValue: 20, maxValue: 100),
          Stat(id: 'relaxation', name: 'Relaxation', icon: 'favorite', initialValue: 30, maxValue: 100),
        ];
      
      case GameType.confidenceQuest:
        return [
          Stat(id: 'confidence', name: 'Confidence', icon: 'star', initialValue: 30, maxValue: 100),
          Stat(id: 'self_esteem', name: 'Self-Esteem', icon: 'emoji_events', initialValue: 25, maxValue: 100),
          Stat(id: 'resilience', name: 'Resilience', icon: 'shield', initialValue: 35, maxValue: 100),
        ];
    }
  }
}

class PhysicsConfig {
  final double gravity; // 9.8 is Earth gravity
  final double bounce;  // 0-1 range for bounciness
  final double speed;   // Game speed multiplier
  
  PhysicsConfig({
    required this.gravity,
    required this.bounce,
    required this.speed,
  });
  
  // Copy with method for immutability
  PhysicsConfig copyWith({
    double? gravity,
    double? bounce,
    double? speed,
  }) {
    return PhysicsConfig(
      gravity: gravity ?? this.gravity,
      bounce: bounce ?? this.bounce,
      speed: speed ?? this.speed,
    );
  }
  
  // Convert to JSON for storage and API
  Map<String, dynamic> toJson() {
    return {
      'gravity': gravity,
      'bounce': bounce,
      'speed': speed,
    };
  }
  
  // Create from JSON
  factory PhysicsConfig.fromJson(Map<String, dynamic> json) {
    return PhysicsConfig(
      gravity: json['gravity'],
      bounce: json['bounce'],
      speed: json['speed'],
    );
  }
}

class GameElement {
  final String id;
  final GameElementType type;
  final Offset position;
  final Size size;
  final Map<String, dynamic> properties;
  
  GameElement({
    required this.id,
    required this.type,
    required this.position,
    required this.size,
    required this.properties,
  });
  
  // Copy with method for immutability
  GameElement copyWith({
    String? id,
    GameElementType? type,
    Offset? position,
    Size? size,
    Map<String, dynamic>? properties,
  }) {
    return GameElement(
      id: id ?? this.id,
      type: type ?? this.type,
      position: position ?? this.position,
      size: size ?? this.size,
      properties: properties ?? this.properties,
    );
  }
  
  // Convert to JSON for storage and API
  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'type': type.toString().split('.').last,
      'position': {'x': position.dx, 'y': position.dy},
      'size': {'width': size.width, 'height': size.height},
      'properties': properties,
    };
  }
  
  // Create from JSON
  factory GameElement.fromJson(Map<String, dynamic> json) {
    return GameElement(
      id: json['id'],
      type: GameElementType.values.firstWhere(
        (e) => e.toString().split('.').last == json['type'],
        orElse: () => GameElementType.platform,
      ),
      position: Offset(
        json['position']['x'],
        json['position']['y'],
      ),
      size: Size(
        json['size']['width'],
        json['size']['height'],
      ),
      properties: Map<String, dynamic>.from(json['properties']),
    );
  }
}

enum MovementType {
  run,
  fly,
  swim,
  hover,
  teleport,
}

class PlayerCharacter {
  final String id;
  final String name;
  final String spriteImage;
  final MovementType movementType;
  final double jumpHeight;
  final double speed;
  final List<String> abilities;
  
  PlayerCharacter({
    required this.id,
    required this.name,
    required this.spriteImage,
    required this.movementType,
    required this.jumpHeight,
    required this.speed,
    required this.abilities,
  });
  
  // Copy with method for immutability
  PlayerCharacter copyWith({
    String? id,
    String? name,
    String? spriteImage,
    MovementType? movementType,
    double? jumpHeight,
    double? speed,
    List<String>? abilities,
  }) {
    return PlayerCharacter(
      id: id ?? this.id,
      name: name ?? this.name,
      spriteImage: spriteImage ?? this.spriteImage,
      movementType: movementType ?? this.movementType,
      jumpHeight: jumpHeight ?? this.jumpHeight,
      speed: speed ?? this.speed,
      abilities: abilities ?? this.abilities,
    );
  }
  
  // Convert to JSON for storage and API
  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'name': name,
      'spriteImage': spriteImage,
      'movementType': movementType.toString().split('.').last,
      'jumpHeight': jumpHeight,
      'speed': speed,
      'abilities': abilities,
    };
  }
  
  // Create from JSON
  factory PlayerCharacter.fromJson(Map<String, dynamic> json) {
    return PlayerCharacter(
      id: json['id'],
      name: json['name'],
      spriteImage: json['spriteImage'],
      movementType: MovementType.values.firstWhere(
        (e) => e.toString().split('.').last == json['movementType'],
        orElse: () => MovementType.run,
      ),
      jumpHeight: json['jumpHeight'],
      speed: json['speed'],
      abilities: List<String>.from(json['abilities']),
    );
  }
}

enum MovementPattern {
  linear,
  zigzag,
  circular,
  follow,
  bounce,
  random,
}

class GameObstacle {
  final String id;
  final String type;
  final String sprite;
  final MovementPattern movementPattern;
  final double speed;
  final int damage;
  final double spawnRate; // per minute
  final Map<String, dynamic> properties;
  
  GameObstacle({
    required this.id,
    required this.type,
    required this.sprite,
    required this.movementPattern,
    required this.speed,
    required this.damage,
    required this.spawnRate,
    required this.properties,
  });
  
  // Copy with method for immutability
  GameObstacle copyWith({
    String? id,
    String? type,
    String? sprite,
    MovementPattern? movementPattern,
    double? speed,
    int? damage,
    double? spawnRate,
    Map<String, dynamic>? properties,
  }) {
    return GameObstacle(
      id: id ?? this.id,
      type: type ?? this.type,
      sprite: sprite ?? this.sprite,
      movementPattern: movementPattern ?? this.movementPattern,
      speed: speed ?? this.speed,
      damage: damage ?? this.damage,
      spawnRate: spawnRate ?? this.spawnRate,
      properties: properties ?? this.properties,
    );
  }
  
  // Convert to JSON for storage and API
  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'type': type,
      'sprite': sprite,
      'movementPattern': movementPattern.toString().split('.').last,
      'speed': speed,
      'damage': damage,
      'spawnRate': spawnRate,
      'properties': properties,
    };
  }
  
  // Create from JSON
  factory GameObstacle.fromJson(Map<String, dynamic> json) {
    return GameObstacle(
      id: json['id'],
      type: json['type'],
      sprite: json['sprite'],
      movementPattern: MovementPattern.values.firstWhere(
        (e) => e.toString().split('.').last == json['movementPattern'],
        orElse: () => MovementPattern.linear,
      ),
      speed: json['speed'],
      damage: json['damage'],
      spawnRate: json['spawnRate'],
      properties: Map<String, dynamic>.from(json['properties']),
    );
  }
}

class GameReward {
  final String id;
  final String type;
  final String sprite;
  final int value;
  final String effect;
  final int duration; // in seconds, 0 for immediate effect
  final Map<String, dynamic> properties;
  
  GameReward({
    required this.id,
    required this.type,
    required this.sprite,
    required this.value,
    required this.effect,
    required this.duration,
    required this.properties,
  });
  
  // Copy with method for immutability
  GameReward copyWith({
    String? id,
    String? type,
    String? sprite,
    int? value,
    String? effect,
    int? duration,
    Map<String, dynamic>? properties,
  }) {
    return GameReward(
      id: id ?? this.id,
      type: type ?? this.type,
      sprite: sprite ?? this.sprite,
      value: value ?? this.value,
      effect: effect ?? this.effect,
      duration: duration ?? this.duration,
      properties: properties ?? this.properties,
    );
  }
  
  // Convert to JSON for storage and API
  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'type': type,
      'sprite': sprite,
      'value': value,
      'effect': effect,
      'duration': duration,
      'properties': properties,
    };
  }
  
  // Create from JSON
  factory GameReward.fromJson(Map<String, dynamic> json) {
    return GameReward(
      id: json['id'],
      type: json['type'],
      sprite: json['sprite'],
      value: json['value'],
      effect: json['effect'],
      duration: json['duration'],
      properties: Map<String, dynamic>.from(json['properties']),
    );
  }
}

class Stat {
  final String id;
  final String name;
  final String icon;
  final int initialValue;
  final int maxValue;
  
  Stat({
    required this.id,
    required this.name,
    required this.icon,
    required this.initialValue,
    required this.maxValue,
  });
  
  // Copy with method for immutability
  Stat copyWith({
    String? id,
    String? name,
    String? icon,
    int? initialValue,
    int? maxValue,
  }) {
    return Stat(
      id: id ?? this.id,
      name: name ?? this.name,
      icon: icon ?? this.icon,
      initialValue: initialValue ?? this.initialValue,
      maxValue: maxValue ?? this.maxValue,
    );
  }
  
  // Convert to JSON for storage and API
  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'name': name,
      'icon': icon,
      'initialValue': initialValue,
      'maxValue': maxValue,
    };
  }
  
  // Create from JSON
  factory Stat.fromJson(Map<String, dynamic> json) {
    return Stat(
      id: json['id'],
      name: json['name'],
      icon: json['icon'],
      initialValue: json['initialValue'],
      maxValue: json['maxValue'],
    );
  }
}