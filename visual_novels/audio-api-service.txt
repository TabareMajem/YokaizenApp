import 'dart:convert';
import 'package:http/http.dart' as http;
import 'package:flutter/material.dart';
import '../models/audio_asset.dart';
import 'audio_api_config.dart';

class AudioApiService {
  // Cache to avoid repeated API calls
  static Map<String, List<AudioAsset>> _cachedResults = {};
  
  // Search across all sources
  static Future<List<AudioAsset>> searchAudio({
    required String query,
    required String type,
    String? source,
  }) async {
    // Check cache first
    final cacheKey = '${query}_${type}_${source ?? "all"}';
    if (_cachedResults.containsKey(cacheKey)) {
      return _cachedResults[cacheKey]!;
    }
    
    List<AudioAsset> results = [];
    
    try {
      // Determine which sources to search
      if (source == null || source == 'All Sources' || source == 'Freesound') {
        if (type == 'sound_effect') {
          final freesoundResults = await searchFreesound(query);
          results.addAll(freesoundResults);
        }
      }
      
      if (source == null || source == 'All Sources' || source == 'MusOpen') {
        if (type == 'music') {
          final musopenResults = await searchMusOpen(query);
          results.addAll(musopenResults);
        }
      }
      
      if (source == null || source == 'All Sources' || source == 'CC Mixter') {
        if (type == 'music') {
          final ccMixterResults = await searchCCMixter(query);
          results.addAll(ccMixterResults);
        }
      }
      
      if (source == null || source == 'All Sources' || source == 'Free Music Archive') {
        if (type == 'music') {
          final fmaResults = await searchFreeMusicArchive(query);
          results.addAll(fmaResults);
        }
      }
      
      if (source == null || source == 'All Sources' || source == 'Uploaded Assets') {
        final uploadedResults = await searchUploadedAssets(query, type);
        results.addAll(uploadedResults);
      }
      
      // Cache results
      _cachedResults[cacheKey] = results;
      
      return results;
    } catch (e) {
      debugPrint('Error searching audio: $e');
      return [];
    }
  }
  
  // Freesound API integration
  static Future<List<AudioAsset>> searchFreesound(String query) async {
    try {
      final url = Uri.parse(
        '${AudioApiConfig.freesoundBaseUrl}/search/text/' +
        '?query=$query&token=${AudioApiConfig.freesoundApiKey}' +
        '&fields=id,name,previews,duration,license,tags'
      );
      
      final response = await http.get(url);
      
      if (response.statusCode == 200) {
        final data = json.decode(response.body);
        final results = data['results'] as List;
        
        return results.map((item) {
          return AudioAsset(
            id: 'freesound_${item['id']}',
            title: item['name'],
            url: item['previews']['preview-hq-mp3'], // Use preview URL
            type: 'sound_effect',
            duration: (item['duration'] as double).round(),
            source: 'Freesound',
            license: item['license'],
            tags: List<String>.from(item['tags']),
          );
        }).toList();
      } else {
        debugPrint('Freesound API error: ${response.statusCode} ${response.body}');
        return [];
      }
    } catch (e) {
      debugPrint('Error searching Freesound: $e');
      return [];
    }
  }
  
  // MusOpen API integration
  static Future<List<AudioAsset>> searchMusOpen(String query) async {
    try {
      final url = Uri.parse(
        '${AudioApiConfig.musopenBaseUrl}/v1/recordings' +
        '?q=$query&key=${AudioApiConfig.musopenApiKey}'
      );
      
      final response = await http.get(url);
      
      if (response.statusCode == 200) {
        final data = json.decode(response.body);
        final results = data['recordings'] as List;
        
        return results.map((item) {
          return AudioAsset(
            id: 'musopen_${item['id']}',
            title: item['title'],
            url: item['url'],
            type: 'music',
            duration: (item['duration'] as double).round(),
            source: 'MusOpen',
            license: 'Public Domain',
            tags: [
              'classical',
              item['composer_name'] ?? '',
              item['form'] ?? '',
            ].where((tag) => tag.isNotEmpty).toList(),
          );
        }).toList();
      } else {
        debugPrint('MusOpen API error: ${response.statusCode} ${response.body}');
        return [];
      }
    } catch (e) {
      debugPrint('Error searching MusOpen: $e');
      return [];
    }
  }
  
  // CC Mixter API integration
  static Future<List<AudioAsset>> searchCCMixter(String query) async {
    try {
      final url = Uri.parse(
        '${AudioApiConfig.ccMixterBaseUrl}/query' +
        '?search=$query&format=json&limit=20'
      );
      
      final response = await http.get(url);
      
      if (response.statusCode == 200) {
        final List<dynamic> data = json.decode(response.body);
        
        return data.map((item) {
          return AudioAsset(
            id: 'ccmixter_${item['upload_id']}',
            title: item['upload_name'],
            url: item['files']['mp3']['download_url'],
            type: 'music',
            duration: int.tryParse(item['files']['mp3']['duration']) ?? 0,
            source: 'CC Mixter',
            license: item['license_name'],
            tags: item['upload_tags'].split(' '),
          );
        }).toList();
      } else {
        debugPrint('CC Mixter API error: ${response.statusCode} ${response.body}');
        return [];
      }
    } catch (e) {
      debugPrint('Error searching CC Mixter: $e');
      return [];
    }
  }
  
  // Free Music Archive API integration
  static Future<List<AudioAsset>> searchFreeMusicArchive(String query) async {
    try {
      final url = Uri.parse(
        '${AudioApiConfig.fmaBaseUrl}/tracks' +
        '?api_key=${AudioApiConfig.freeMusicArchiveApiKey}' +
        '&q=$query&limit=20'
      );
      
      final response = await http.get(url);
      
      if (response.statusCode == 200) {
        final data = json.decode(response.body);
        final results = data['dataset'] as List;
        
        return results.map((item) {
          // Extract tags from genres
          List<String> tags = [];
          if (item['genre'] != null) {
            tags.add(item['genre']);
          }
          
          return AudioAsset(
            id: 'fma_${item['track_id']}',
            title: item['track_title'],
            url: item['track_url'],
            type: 'music',
            duration: int.tryParse(item['track_duration'] ?? '0') ?? 0,
            source: 'Free Music Archive',
            license: item['license_title'],
            tags: tags,
          );
        }).toList();
      } else {
        debugPrint('FMA API error: ${response.statusCode} ${response.body}');
        return [];
      }
    } catch (e) {
      debugPrint('Error searching Free Music Archive: $e');
      return [];
    }
  }
  
  // Uploaded assets API integration
  static Future<List<AudioAsset>> searchUploadedAssets(String query, String type) async {
    try {
      final url = Uri.parse(
        '${AudioApiConfig.backendAudioEndpoint}/search' +
        '?q=$query&type=$type'
      );
      
      final response = await http.get(url);
      
      if (response.statusCode == 200) {
        final data = json.decode(response.body);
        final results = data['results'] as List;
        
        return results.map((item) => AudioAsset.fromJson(item)).toList();
      } else {
        debugPrint('Backend API error: ${response.statusCode} ${response.body}');
        return [];
      }
    } catch (e) {
      debugPrint('Error searching uploaded assets: $e');
      // For development, return mock data
      return _getMockUploadedAssets(query, type);
    }
  }
  
  // Upload a new audio file
  static Future<AudioAsset?> uploadAudioFile(
    String filename,
    List<int> bytes,
    String title,
    String type,
    List<String> tags,
  ) async {
    try {
      // Create multipart request
      var request = http.MultipartRequest(
        'POST',
        Uri.parse('${AudioApiConfig.backendAudioEndpoint}/upload'),
      );
      
      // Add file
      request.files.add(
        http.MultipartFile.fromBytes(
          'audio',
          bytes,
          filename: filename,
        ),
      );
      
      // Add metadata
      request.fields['title'] = title;
      request.fields['type'] = type;
      request.fields['source'] = 'Uploaded Assets';
      request.fields['license'] = 'Custom';
      request.fields['tags'] = tags.join(',');
      
      // Send the request
      var streamedResponse = await request.send();
      var response = await http.Response.fromStream(streamedResponse);
      
      if (response.statusCode == 200) {
        final data = json.decode(response.body);
        return AudioAsset.fromJson(data);
      } else {
        debugPrint('Upload error: ${response.statusCode} ${response.body}');
        return null;
      }
    } catch (e) {
      debugPrint('Error uploading audio: $e');
      return null;
    }
  }
  
  // Get details for a specific audio asset
  static Future<AudioAsset?> getAudioAsset(String id) async {
    // Check all cached results first
    for (var assets in _cachedResults.values) {
      for (var asset in assets) {
        if (asset.id == id) {
          return asset;
        }
      }
    }
    
    // If not found in cache, fetch from API
    try {
      final url = Uri.parse('${AudioApiConfig.backendAudioEndpoint}/asset/$id');
      final response = await http.get(url);
      
      if (response.statusCode == 200) {
        final data = json.decode(response.body);
        return AudioAsset.fromJson(data);
      } else {
        debugPrint('Asset fetch error: ${response.statusCode} ${response.body}');
        return null;
      }
    } catch (e) {
      debugPrint('Error fetching audio asset: $e');
      // For development, return mock asset
      return _getMockAudioAsset(id);
    }
  }
  
  // Clear the cache
  static void clearCache() {
    _cachedResults.clear();
  }
  
  // Mock data for development
  static List<AudioAsset> _getMockUploadedAssets(String query, String type) {
    final List<AudioAsset> mockAssets = [
      AudioAsset(
        id: 'upload_1',
        title: 'Custom Background Music',
        url: 'https://example.com/uploads/background.mp3',
        type: 'music',
        duration: 180,
        source: 'Uploaded Assets',
        license: 'Custom',
        tags: ['background', 'calm', 'custom'],
      ),
      AudioAsset(
        id: 'upload_2',
        title: 'UI Click Sound',
        url: 'https://example.com/uploads/click.mp3',
        type: 'sound_effect',
        duration: 1,
        source: 'Uploaded Assets',
        license: 'Custom',
        tags: ['ui', 'click', 'button'],
      ),
    ];
    
    // Filter by type
    List<AudioAsset> filtered = mockAssets.where((asset) => asset.type == type).toList();
    
    // Filter by query if not empty
    if (query.isNotEmpty) {
      filtered = filtered.where((asset) {
        return asset.title.toLowerCase().contains(query.toLowerCase()) ||
               asset.tags.any((tag) => tag.toLowerCase().contains(query.toLowerCase()));
      }).toList();
    }
    
    return filtered;
  }
  
  static AudioAsset? _getMockAudioAsset(String id) {
    // For development, return a mock asset based on ID
    if (id.startsWith('freesound_')) {
      return AudioAsset(
        id: id,
        title: 'Mock Freesound Asset',
        url: 'https://example.com/mock_sound.mp3',
        type: 'sound_effect',
        duration: 2,
        source: 'Freesound',
        license: 'CC BY',
        tags: ['mock', 'sound', 'effect'],
      );
    } else if (id.startsWith('musopen_')) {
      return AudioAsset(
        id: id,
        title: 'Mock MusOpen Asset',
        url: 'https://example.com/mock_music.mp3',
        type: 'music',
        duration: 120,
        source: 'MusOpen',
        license: 'Public Domain',
        tags: ['mock', 'classical', 'music'],
      );
    } else if (id.startsWith('upload_')) {
      return AudioAsset(
        id: id,
        title: 'Mock Uploaded Asset',
        url: 'https://example.com/mock_upload.mp3',
        type: id.contains('music') ? 'music' : 'sound_effect',
        duration: 60,
        source: 'Uploaded Assets',
        license: 'Custom',
        tags: ['mock', 'upload'],
      );
    }
    
    return null;
  }
}