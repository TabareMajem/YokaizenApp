from flask import Flask, request, jsonify, send_from_directory
from flask_cors import CORS
from werkzeug.utils import secure_filename
import os
import json
import uuid
import datetime
import requests
from functools import wraps
import logging

# Import your existing authentication middleware
from your_existing_auth import auth_required, get_current_user

# Set up logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Initialize Flask app
app = Flask(__name__)
CORS(app)  # Enable CORS for all routes

# Configuration
app.config['UPLOAD_FOLDER'] = os.environ.get('UPLOAD_FOLDER', 'uploads')
app.config['MAX_CONTENT_LENGTH'] = 16 * 1024 * 1024  # 16MB max upload
app.config['ALLOWED_IMAGE_EXTENSIONS'] = {'png', 'jpg', 'jpeg', 'gif', 'svg'}
app.config['ALLOWED_AUDIO_EXTENSIONS'] = {'mp3', 'wav', 'ogg', 'm4a'}

# Audio API configuration
FREESOUND_API_KEY = os.environ.get('FREESOUND_API_KEY', '')
MUSOPEN_API_KEY = os.environ.get('MUSOPEN_API_KEY', '')
FMA_API_KEY = os.environ.get('FMA_API_KEY', '')

# Ensure upload directories exist
for directory in ['images', 'audio', 'backgrounds', 'characters']:
    os.makedirs(os.path.join(app.config['UPLOAD_FOLDER'], directory), exist_ok=True)

# Helper function to check allowed file extensions
def allowed_file(filename, allowed_extensions):
    return '.' in filename and \
           filename.rsplit('.', 1)[1].lower() in allowed_extensions

# Database connection (use your existing database connection)
from your_database_module import db, query_db, insert_db, update_db, delete_db

# Content management endpoints
@app.route('/api/content', methods=['GET'])
@auth_required
def list_content():
    """List all content modules with filtering options"""
    try:
        # Get query parameters
        content_type = request.args.get('type')
        limit = int(request.args.get('limit', 100))
        offset = int(request.args.get('offset', 0))
        
        # Build query
        query = "SELECT * FROM content_modules"
        params = []
        
        if content_type:
            query += " WHERE content_type = ?"
            params.append(content_type)
            
        # Add ordering and pagination
        query += " ORDER BY updated_at DESC LIMIT ? OFFSET ?"
        params.extend([limit, offset])
        
        # Execute query
        content_list = query_db(query, params)
        
        # Count total (for pagination)
        count_query = "SELECT COUNT(*) as count FROM content_modules"
        if content_type:
            count_query += " WHERE content_type = ?"
            count_params = [content_type]
        else:
            count_params = []
            
        count_result = query_db(count_query, count_params, one=True)
        
        return jsonify({
            "content": content_list,
            "total": count_result['count'],
            "limit": limit,
            "offset": offset
        })
        
    except Exception as e:
        logger.error(f"Error listing content: {str(e)}")
        return jsonify({"error": str(e)}), 500

@app.route('/api/content/<content_id>', methods=['GET'])
@auth_required
def get_content(content_id):
    """Get a specific content module by ID"""
    try:
        content = query_db("SELECT * FROM content_modules WHERE id = ?", [content_id], one=True)
        
        if not content:
            return jsonify({"error": "Content not found"}), 404
            
        # Parse the JSON data field
        content['data'] = json.loads(content['data'])
        
        return jsonify(content)
        
    except Exception as e:
        logger.error(f"Error getting content {content_id}: {str(e)}")
        return jsonify({"error": str(e)}), 500

@app.route('/api/content', methods=['POST'])
@auth_required
def create_content():
    """Create a new content module"""
    try:
        data = request.json
        
        # Validate required fields
        required_fields = ['title', 'content_type', 'data']
        for field in required_fields:
            if field not in data:
                return jsonify({"error": f"Missing required field: {field}"}), 400
                
        # Generate ID if not provided
        content_id = data.get('id', f"{data['content_type']}_{uuid.uuid4().hex[:8]}")
        
        # Add creator info
        current_user = get_current_user()
        
        # Store data as JSON string
        if isinstance(data['data'], str):
            json_data = data['data']
        else:
            json_data = json.dumps(data['data'])
        
        # Insert into database
        insert_db(
            "INSERT INTO content_modules (id, title, description, content_type, data, creator_id, created_at, updated_at, version, status) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",
            [
                content_id,
                data['title'],
                data.get('description', ''),
                data['content_type'],
                json_data,
                current_user['id'],
                datetime.datetime.now(),
                datetime.datetime.now(),
                data.get('version', '1.0.0'),
                data.get('status', 'draft')
            ]
        )
        
        return jsonify({
            "id": content_id,
            "status": "created",
            "message": "Content module created successfully"
        })
        
    except Exception as e:
        logger.error(f"Error creating content: {str(e)}")
        return jsonify({"error": str(e)}), 500

@app.route('/api/content/<content_id>', methods=['PUT'])
@auth_required
def update_content(content_id):
    """Update an existing content module"""
    try:
        data = request.json
        
        # Check if content exists
        content = query_db("SELECT * FROM content_modules WHERE id = ?", [content_id], one=True)
        if not content:
            return jsonify({"error": "Content not found"}), 404
            
        # Verify ownership or admin status
        current_user = get_current_user()
        if content['creator_id'] != current_user['id'] and not current_user.get('is_admin', False):
            return jsonify({"error": "Not authorized to update this content"}), 403
            
        # Update fields
        updates = {}
        for field in ['title', 'description', 'status', 'version']:
            if field in data:
                updates[field] = data[field]
                
        # Handle data field specially (it's JSON)
        if 'data' in data:
            if isinstance(data['data'], str):
                updates['data'] = data['data']
            else:
                updates['data'] = json.dumps(data['data'])
                
        # Add updated timestamp
        updates['updated_at'] = datetime.datetime.now()
        
        # Build update query
        fields = ', '.join([f"{field} = ?" for field in updates])
        values = list(updates.values())
        values.append(content_id)  # For the WHERE clause
        
        update_db(
            f"UPDATE content_modules SET {fields} WHERE id = ?",
            values
        )
        
        return jsonify({
            "id": content_id,
            "status": "updated",
            "message": "Content module updated successfully"
        })
        
    except Exception as e:
        logger.error(f"Error updating content {content_id}: {str(e)}")
        return jsonify({"error": str(e)}), 500

@app.route('/api/content/<content_id>', methods=['DELETE'])
@auth_required
def delete_content(content_id):
    """Delete a content module"""
    try:
        # Check if content exists
        content = query_db("SELECT * FROM content_modules WHERE id = ?", [content_id], one=True)
        if not content:
            return jsonify({"error": "Content not found"}), 404
            
        # Verify ownership or admin status
        current_user = get_current_user()
        if content['creator_id'] != current_user['id'] and not current_user.get('is_admin', False):
            return jsonify({"error": "Not authorized to delete this content"}), 403
            
        # Delete from database
        delete_db("DELETE FROM content_modules WHERE id = ?", [content_id])
        
        return jsonify({
            "id": content_id,
            "status": "deleted",
            "message": "Content module deleted successfully"
        })
        
    except Exception as e:
        logger.error(f"Error deleting content {content_id}: {str(e)}")
        return jsonify({"error": str(e)}), 500

# Asset management endpoints
@app.route('/api/assets/upload', methods=['POST'])
@auth_required
def upload_asset():
    """Upload an asset (image, audio, etc.)"""
    try:
        if 'file' not in request.files:
            return jsonify({"error": "No file part"}), 400
            
        file = request.files['file']
        
        if file.filename == '':
            return jsonify({"error": "No selected file"}), 400
            
        asset_type = request.form.get('type', 'image')
        tags = request.form.get('tags', '').split(',')
        
        # Validate file type based on asset type
        if asset_type == 'audio':
            if not allowed_file(file.filename, app.config['ALLOWED_AUDIO_EXTENSIONS']):
                return jsonify({"error": "File type not allowed"}), 400
            directory = 'audio'
        else:  # image assets (backgrounds, characters, etc.)
            if not allowed_file(file.filename, app.config['ALLOWED_IMAGE_EXTENSIONS']):
                return jsonify({"error": "File type not allowed"}), 400
            directory = asset_type if asset_type in ['backgrounds', 'characters'] else 'images'
            
        # Ensure unique filename
        filename = secure_filename(file.filename)
        base_name, extension = os.path.splitext(filename)
        unique_filename = f"{base_name}_{uuid.uuid4().hex[:6]}{extension}"
        
        # Save file
        file_path = os.path.join(app.config['UPLOAD_FOLDER'], directory, unique_filename)
        file.save(file_path)
        
        # Get file size and mime type
        file_size = os.path.getsize(file_path)
        mime_type = file.content_type
        
        # Get current user
        current_user = get_current_user()
        
        # Generate asset ID
        asset_id = f"{asset_type}_{uuid.uuid4().hex[:8]}"
        
        # Insert asset record into database
        insert_db(
            "INSERT INTO assets (id, name, file_path, asset_type, mime_type, size, tags, uploader_id, uploaded_at) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)",
            [
                asset_id,
                request.form.get('name', filename),
                f"/{directory}/{unique_filename}",
                asset_type,
                mime_type,
                file_size,
                json.dumps(tags),
                current_user['id'],
                datetime.datetime.now()
            ]
        )
        
        # Return asset information
        return jsonify({
            "id": asset_id,
            "name": request.form.get('name', filename),
            "url": f"/api/assets/{directory}/{unique_filename}",
            "type": asset_type,
            "size": file_size,
            "mime_type": mime_type,
            "tags": tags
        })
        
    except Exception as e:
        logger.error(f"Error uploading asset: {str(e)}")
        return jsonify({"error": str(e)}), 500

@app.route('/api/assets', methods=['GET'])
@auth_required
def list_assets():
    """List assets with filtering options"""
    try:
        # Get query parameters
        asset_type = request.args.get('type')
        tag = request.args.get('tag')
        query_term = request.args.get('q')
        limit = int(request.args.get('limit', 100))
        offset = int(request.args.get('offset', 0))
        
        # Build query
        query = "SELECT * FROM assets"
        conditions = []
        params = []
        
        if asset_type:
            conditions.append("asset_type = ?")
            params.append(asset_type)
            
        if tag:
            conditions.append("tags LIKE ?")
            params.append(f"%{tag}%")
            
        if query_term:
            conditions.append("name LIKE ?")
            params.append(f"%{query_term}%")
            
        if conditions:
            query += " WHERE " + " AND ".join(conditions)
            
        # Add ordering and pagination
        query += " ORDER BY uploaded_at DESC LIMIT ? OFFSET ?"
        params.extend([limit, offset])
        
        # Execute query
        assets = query_db(query, params)
        
        # Parse tags JSON
        for asset in assets:
            asset['tags'] = json.loads(asset['tags'])
            
        # Count total (for pagination)
        count_query = "SELECT COUNT(*) as count FROM assets"
        if conditions:
            count_query += " WHERE " + " AND ".join(conditions)
            
        count_result = query_db(count_query, params[:-2], one=True)
        
        return jsonify({
            "assets": assets,
            "total": count_result['count'],
            "limit": limit,
            "offset": offset
        })
        
    except Exception as e:
        logger.error(f"Error listing assets: {str(e)}")
        return jsonify({"error": str(e)}), 500

@app.route('/api/assets/<asset_id>', methods=['DELETE'])
@auth_required
def delete_asset(asset_id):
    """Delete an asset"""
    try:
        # Check if asset exists
        asset = query_db("SELECT * FROM assets WHERE id = ?", [asset_id], one=True)
        if not asset:
            return jsonify({"error": "Asset not found"}), 404
            
        # Verify ownership or admin status
        current_user = get_current_user()
        if asset['uploader_id'] != current_user['id'] and not current_user.get('is_admin', False):
            return jsonify({"error": "Not authorized to delete this asset"}), 403
            
        # Delete file
        try:
            os.remove(os.path.join(app.config['UPLOAD_FOLDER'], asset['file_path'].lstrip('/')))
        except OSError as e:
            logger.warning(f"Could not delete file {asset['file_path']}: {str(e)}")
            
        # Delete from database
        delete_db("DELETE FROM assets WHERE id = ?", [asset_id])
        
        return jsonify({
            "id": asset_id,
            "status": "deleted",
            "message": "Asset deleted successfully"
        })
        
    except Exception as e:
        logger.error(f"Error deleting asset {asset_id}: {str(e)}")
        return jsonify({"error": str(e)}), 500

@app.route('/api/assets/<path:filename>', methods=['GET'])
def serve_asset(filename):
    """Serve asset files"""
    return send_from_directory(app.config['UPLOAD_FOLDER'], filename)

# Audio integration endpoints
@app.route('/api/audio/search', methods=['GET'])
@auth_required
def search_audio():
    """Search for audio across various sources"""
    try:
        # Get query parameters
        query = request.args.get('q', '')
        source = request.args.get('source', 'all')
        audio_type = request.args.get('type', 'all')
        limit = int(request.args.get('limit', 20))
        
        results = []
        
        # Search Freesound
        if source in ['all', 'freesound'] and (audio_type in ['all', 'sound_effect']):
            freesound_results = search_freesound(query, limit)
            results.extend(freesound_results)
            
        # Search MusOpen
        if source in ['all', 'musopen'] and (audio_type in ['all', 'music']):
            musopen_results = search_musopen(query, limit)
            results.extend(musopen_results)
            
        # Search Free Music Archive
        if source in ['all', 'fma'] and (audio_type in ['all', 'music']):
            fma_results = search_free_music_archive(query, limit)
            results.extend(fma_results)
            
        # Search uploaded assets
        if source in ['all', 'uploaded']:
            uploaded_results = search_uploaded_audio(query, audio_type, limit)
            results.extend(uploaded_results)
            
        # Limit total results
        if len(results) > limit:
            results = results[:limit]
            
        return jsonify({"results": results})
        
    except Exception as e:
        logger.error(f"Error searching audio: {str(e)}")
        return jsonify({"error": str(e)}), 500

def search_freesound(query, limit=20):
    """Search Freesound API for sound effects"""
    if not FREESOUND_API_KEY:
        logger.warning("Freesound API key not configured")
        return []
        
    try:
        url = f"https://freesound.org/apiv2/search/text/?query={query}&token={FREESOUND_API_KEY}&fields=id,name,previews,duration,license,tags&page_size={limit}"
        response = requests.get(url, timeout=5)
        
        if response.status_code == 200:
            data = response.json()
            results = []
            
            for item in data.get('results', []):
                results.append({
                    "id": f"freesound_{item['id']}",
                    "title": item['name'],
                    "url": item['previews']['preview-hq-mp3'],
                    "type": "sound_effect",
                    "duration": int(item['duration']),
                    "source": "Freesound",
                    "license": item['license'],
                    "tags": item.get('tags', [])[:5]  # Limit to 5 tags
                })
                
            return results
        else:
            logger.warning(f"Freesound API error: {response.status_code} {response.text}")
            return []
            
    except Exception as e:
        logger.error(f"Error searching Freesound: {str(e)}")
        return []

def search_musopen(query, limit=20):
    """Search MusOpen API for classical music"""
    if not MUSOPEN_API_KEY:
        logger.warning("MusOpen API key not configured")
        return []
        
    try:
        url = f"https://musopen.org/api/v1/recordings?q={query}&key={MUSOPEN_API_KEY}&limit={limit}"
        response = requests.get(url, timeout=5)
        
        if response.status_code == 200:
            data = response.json()
            results = []
            
            for item in data.get('recordings', []):
                # Filter out items with no url
                if not item.get('url'):
                    continue
                    
                results.append({
                    "id": f"musopen_{item['id']}",
                    "title": item['title'],
                    "url": item['url'],
                    "type": "music",
                    "duration": int(float(item.get('duration', 0))),
                    "source": "MusOpen",
                    "license": "Public Domain",
                    "tags": [
                        "classical",
                        item.get('composer_name', ''),
                        item.get('form', '')
                    ]
                })
                
            return results
        else:
            logger.warning(f"MusOpen API error: {response.status_code} {response.text}")
            return []
            
    except Exception as e:
        logger.error(f"Error searching MusOpen: {str(e)}")
        return []

def search_free_music_archive(query, limit=20):
    """Search Free Music Archive API for music"""
    if not FMA_API_KEY:
        logger.warning("FMA API key not configured")
        return []
        
    try:
        url = f"https://freemusicarchive.org/api/tracks?api_key={FMA_API_KEY}&q={query}&limit={limit}"
        response = requests.get(url, timeout=5)
        
        if response.status_code == 200:
            data = response.json()
            results = []
            
            for item in data.get('dataset', []):
                # Extract tags from genres
                tags = []
                if item.get('genre'):
                    tags.append(item['genre'])
                    
                results.append({
                    "id": f"fma_{item['track_id']}",
                    "title": item['track_title'],
                    "url": item['track_url'],
                    "type": "music",
                    "duration": int(item.get('track_duration', 0) or 0),
                    "source": "Free Music Archive",
                    "license": item.get('license_title', 'Unknown'),
                    "tags": tags
                })
                
            return results
        else:
            logger.warning(f"FMA API error: {response.status_code} {response.text}")
            return []
            
    except Exception as e:
        logger.error(f"Error searching FMA: {str(e)}")
        return []

def search_uploaded_audio(query, audio_type='all', limit=20):
    """Search uploaded audio assets"""
    try:
        # Build query
        sql_query = "SELECT * FROM assets WHERE asset_type = 'audio'"
        params = []
        
        if query:
            sql_query += " AND (name LIKE ? OR tags LIKE ?)"
            params.extend([f"%{query}%", f"%{query}%"])
            
        if audio_type != 'all':
            # For uploaded assets, we need to look at tags to determine type
            if audio_type == 'music':
                sql_query += " AND (tags LIKE ? OR tags LIKE ?)"
                params.extend(["%music%", "%soundtrack%"])
            elif audio_type == 'sound_effect':
                sql_query += " AND (tags LIKE ? OR tags LIKE ?)"
                params.extend(["%effect%", "%sfx%"])
                
        sql_query += " ORDER BY uploaded_at DESC LIMIT ?"
        params.append(limit)
        
        # Execute query
        assets = query_db(sql_query, params)
        
        results = []
        for asset in assets:
            # Determine type based on tags
            asset_type = "sound_effect"
            tags = json.loads(asset['tags'])
            
            if any(tag in ['music', 'soundtrack', 'song', 'track'] for tag in tags):
                asset_type = "music"
                
            results.append({
                "id": asset['id'],
                "title": asset['name'],
                "url": f"/api/assets/{asset['file_path']}",
                "type": asset_type,
                "duration": 0,  # We don't store duration in database, would need audio analysis
                "source": "Uploaded Assets",
                "license": "Custom",
                "tags": tags
            })
            
        return results
        
    except Exception as e:
        logger.error(f"Error searching uploaded audio: {str(e)}")
        return []

@app.route('/api/audio/<source>/<id>', methods=['GET'])
@auth_required
def get_audio_details(source, id):
    """Get details for a specific audio asset"""
    try:
        if source == 'uploaded':
            # Fetch from database
            asset = query_db("SELECT * FROM assets WHERE id = ?", [id], one=True)
            
            if not asset:
                return jsonify({"error": "Audio asset not found"}), 404
                
            # Parse tags
            tags = json.loads(asset['tags'])
            
            # Determine type based on tags
            asset_type = "sound_effect"
            if any(tag in ['music', 'soundtrack', 'song', 'track'] for tag in tags):
                asset_type = "music"
                
            return jsonify({
                "id": asset['id'],
                "title": asset['name'],
                "url": f"/api/assets/{asset['file_path']}",
                "type": asset_type,
                "duration": 0,  # We don't store duration
                "source": "Uploaded Assets",
                "license": "Custom",
                "tags": tags
            })
            
        elif source == 'freesound':
            # Extract Freesound ID
            freesound_id = id.replace('freesound_', '')
            
            # Call Freesound API
            url = f"https://freesound.org/apiv2/sounds/{freesound_id}/?token={FREESOUND_API_KEY}"
            response = requests.get(url, timeout=5)
            
            if response.status_code == 200:
                item = response.json()
                
                return jsonify({
                    "id": f"freesound_{item['id']}",
                    "title": item['name'],
                    "url": item['previews']['preview-hq-mp3'],
                    "type": "sound_effect",
                    "duration": int(item['duration']),
                    "source": "Freesound",
                    "license": item['license'],
                    "tags": item.get('tags', [])[:5]
                })
            else:
                return jsonify({"error": f"Freesound API error: {response.status_code}"}), 404
                
        # Add handlers for other sources (MusOpen, FMA) as needed
                
        return jsonify({"error": "Unsupported audio source"}), 400
        
    except Exception as e:
        logger.error(f"Error getting audio details: {str(e)}")
        return jsonify({"error": str(e)}), 500

# Deployment endpoints
@app.route('/api/deploy/<content_id>', methods=['POST'])
@auth_required
def deploy_content(content_id):
    """Deploy content to the app"""
    try:
        # Check if content exists
        content = query_db("SELECT * FROM content_modules WHERE id = ?", [content_id], one=True)
        if not content:
            return jsonify({"error": "Content not found"}), 404
            
        # Verify authorization
        current_user = get_current_user()
        if content['creator_id'] != current_user['id'] and not current_user.get('is_admin', False):
            return jsonify({"error": "Not authorized to deploy this content"}), 403
            
        # Validate content
        try:
            content_data = json.loads(content['data'])
            
            # Basic validation based on content type
            if content['content_type'] == 'story':
                if 'nodes' not in content_data or not content_data['nodes']:
                    return jsonify({"error": "Story must have at least one dialogue node"}), 400
            elif content['content_type'] == 'game':
                if 'gameType' not in content_data:
                    return jsonify({"error": "Game must specify a game type"}), 400
            elif content['content_type'] == 'cbt_exercise':
                if 'exerciseType' not in content_data:
                    return jsonify({"error": "CBT exercise must specify an exercise type"}), 400
            elif content['content_type'] == 'quiz':
                if 'questions' not in content_data or not content_data['questions']:
                    return jsonify({"error": "Quiz must have at least one question"}), 400
            else:
                return jsonify({"error": f"Unsupported content type: {content['content_type']}"}), 400
                
        except json.JSONDecodeError:
            return jsonify({"error": "Invalid content data format"}), 400
            
        # Generate deployment ID
        deploy_id = f"deploy_{uuid.uuid4().hex[:8]}"
        
        # Set content to 'published' status
        update_db(
            "UPDATE content_modules SET status = ?, updated_at = ? WHERE id = ?",
            ['published', datetime.datetime.now(), content_id]
        )
        
        # Create deployment record
        insert_db(
            "INSERT INTO deployments (id, content_id, version, status, deployed_at, deployed_by) VALUES (?, ?, ?, ?, ?, ?)",
            [
                deploy_id,
                content_id,
                content['version'],
                'success',  # For simplicity, assuming immediate success
                datetime.datetime.now(),
                current_user['id']
            ]
        )
        
        # In a real system, you might have a more complex deployment process
        # such as asset optimization, CDN uploading, etc.
        
        return jsonify({
            "deploy_id": deploy_id,
            "content_id": content_id,
            "status": "success",
            "message": "Content deployed successfully"
        })
        
    except Exception as e:
        logger.error(f"Error deploying content {content_id}: {str(e)}")
        return jsonify({"error": str(e)}), 500

@app.route('/api/deploy/status/<deploy_id>', methods=['GET'])
@auth_required
def deployment_status(deploy_id):
    """Check deployment status"""
    try:
        deployment = query_db("SELECT * FROM deployments WHERE id = ?", [deploy_id], one=True)
        
        if not deployment:
            return jsonify({"error": "Deployment not found"}), 404
            
        return jsonify(deployment)
        
    except Exception as e:
        logger.error(f"Error checking deployment status {deploy_id}: {str(e)}")
        return jsonify({"error": str(e)}), 500
        
@app.route('/api/deployments', methods=['GET'])
@auth_required
def list_deployments():
    """List deployments with filtering options"""
    try:
        # Get query parameters
        content_id = request.args.get('content_id')
        limit = int(request.args.get('limit', 100))
        offset = int(request.args.get('offset', 0))
        
        # Build query
        query = "SELECT d.*, c.title as content_title, c.content_type FROM deployments d JOIN content_modules c ON d.content_id = c.id"
        conditions = []
        params = []
        
        if content_id:
            conditions.append("d.content_id = ?")
            params.append(content_id)
            
        if conditions:
            query += " WHERE " + " AND ".join(conditions)
            
        # Add ordering and pagination
        query += " ORDER BY d.deployed_at DESC LIMIT ? OFFSET ?"
        params.extend([limit, offset])
        
        # Execute query
        deployments = query_db(query, params)
        
        # Count total (for pagination)
        count_query = "SELECT COUNT(*) as count FROM deployments d"
        if conditions:
            count_query += " WHERE " + " AND ".join(conditions)
            
        count_result = query_db(count_query, params[:-2], one=True)
        
        return jsonify({
            "deployments": deployments,
            "total": count_result['count'],
            "limit": limit,
            "offset": offset
        })
        
    except Exception as e:
        logger.error(f"Error listing deployments: {str(e)}")
        return jsonify({"error": str(e)}), 500

# Error handlers
@app.errorhandler(404)
def not_found(error):
    return jsonify({"error": "Resource not found"}), 404

@app.errorhandler(500)
def server_error(error):
    return jsonify({"error": "Internal server error"}), 500

# Main entry point
if __name__ == '__main__':
    port = int(os.environ.get('PORT', 5000))
    app.run(host='0.0.0.0', port=port, debug=os.environ.get('DEBUG', 'False').lower() == 'true')
